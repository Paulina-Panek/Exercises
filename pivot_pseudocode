Paulina Panek  4/14/2019

Assumption: flat table doesn't have header a row/column, columns follow the same order as in the struct, last entry followed by a null sign

define struct person
{
    char name[15]
    char city[15]
    char state[2]
    char item[15]
    float price
    struct person* link_back
}

*********************************************
*  Create a linked-list from the flat table *
*********************************************

define a pointer to person called start
define a pointer to person called end
define a pointer to person called temp_prev
define a pointer to person called temp_next
define integers i, j

copy from NULL to start
copy from NULL to end
copy from NULL to temp_prev
copy from NULL to temp_next

void function makePivot (flat_table[][], rowfield[2], columnfield[], datafield[2])
{
    i = 0, j = 0
    
    while (end of table not reached)      /* null sign or predefined size) */
    {
        if start == NULL
        {
            allocate a heap space and store its address into start
            copy from start to temp_next
        }
        else
        {
            allocate a heap space and store its address into temp_next
        }
        
        copy from flat_table[i][j] to temp_next->name
        copy from flat_table[i][j+1] to temp_next->city
        copy from flat_table[i][j+2] to temp_next->state
        copy from flat_table[i][j+3] to temp_next->item
        copy from flat_table[i][j+4] to temp_next->price
        copy from temp_prev to temp_next->link_back
        copy from temp_next to temp_prev
        i++      /* (i+1) = number of persons = number of rows in flat table */
    }
    copy from temp_prev to end
    
    ****************************************************
    *   Values after creating the linked-list:         *
    *   start = ptr to person with NULL in link_back   *
    *   temp_prev = ptr to "end person"                *
    *   temp_next = ptr to "end person"                *
    *   end = ptr to "end person"                      *
    ****************************************************
    
    ****************************************************
    *     Assumptions about pivot config:              *
    *          rowfield[0] = state                     *
    *          rowfield[1] = city                      *
    *          columnfield = data                      *
    *          datafield[0] = sumCity                  *
    *          datafield[1] = sumPrice                 *
    *          parameters_num = 4                      *
    ****************************************************
   
   allocate pivot[i+2][4] array        /* max size, might not all be used, adds a row for total sum */
   initiate pivot array with null signs

index = 0

for (Not empty linked list)
{
   copy from temp_prev->state to pivot[index][0]
   copy from temp_prev->city to pivot[index][1]
   /* can't sum cities so leaving that blank */
   copy from temp_prev->price to pivot[index][3]
   copy from temp_prev->link_back to temp_next
   copy from temp_next to end
   endCheck = removeFromLL(temp_prev)
 
   while (endCheck)
   {
        if sameStateCity(pivot[index][0], pivot[index][1], temp_prev) == 1
        {
             pivot[0][3] = pivot[0][3] + temp_prev->price
             endCheck = removeFromLL(temp_prev)
        }
        else
        {
            endCheck = MoveToNextPerson(temp_prev, temp_next, end)
        }
    }
    index++
}


***********************************************           
* functions:                                  *
***********************************************
 
 int sameStateCity(char [] state, char [] city, struct person * person_ptr)
 {
     int rtrn;
     
     rtrn = 0
     
     if (state == person_pointer->state)     // use string library to compare //
     {
       if city == person_pointer->city
       {
           rtrn = 1
       }
     }   
     return(rtrn)
 }
 
  int MoveToNextPerson(struct person* temp_prev, struct person* temp_next)
  {
      int rtrn
      
      if (temp_next->link_back == NULL)
      {
          rtrn = 0
      }
      else
      {
          temp_prev = temp_next
          temp_next = temp_next->link_back
          rtrn = 1
      }

    return(rtrn)
    }
    
    int removeFromLL(temp_prev)
    
    int rtrn
    
    rtrn = 1
    
    {
        deallocate (temp_prev)
        copy from temp_next to temp_prev
        copy from temp prev->link_back to temp_next
        if temp_prev == NULL
        {
            rtrn == 0
        }
        
        return(rtrn)
    }
